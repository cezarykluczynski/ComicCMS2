<?php
/**
 * View helper for displaying Angular templates.
 *
 * @package ComicCMS2
 * @author Cezary KluczyÅ„ski
 * @license https://github.com/cezarykluczynski/ComicCMS2/blob/master/LICENSE.txt MIT
 */

namespace Application\View\Helper;

use Zend\View\Helper\AbstractHelper;
use Zend\Stdlib\ArrayUtils;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RegexIterator;
use RecursiveRegexIterator;
use Zend\View\Renderer\PhpRenderer;
use Zend\View\Resolver;
use Zend\View\Model\ViewModel;

class AngularTemplates extends AbstractHelper
{
    /**
     * When invoked, This function will pass all defined Angular templates as a string.
     *
     * @throws \Exception        If requested group cannot be found in config.
     * @param  string     $group Group name, configured in ["view_manager"]["angular_templates"].
     * @return string            All templates as a single string.
     */
    public function __invoke($group)
    {
        /** @var \Zend\Di\ServiceLocator */
        $sm = $this->getView()->getHelperPluginManager()->getServiceLocator();

        /** @var array Angular templates config. */
        $angularTemplates = $sm->get('config')['view_manager']['angular_templates'];

        /** Don't allow requesting group that's do not exist. Likely something we wan't to catch early. */
        if (!isset($angularTemplates[$group]))
        {
            throw new \Exception( "Unkown Angular templates group \"$group\" cannot be rendered." );
        }

        $templates = array();

        /** Build list of templates. */
        foreach($angularTemplates[$group] as $directory)
        {
            $templates = ArrayUtils::merge($templates, $this->gatherTemplates($directory));
        }

        /** @var array Rendered templates. */
        $templates = $this->render($templates);

        /** Return as a single string in a wrapper. */
        return "<div class=\"angular-templates\">" . implode("\r\r", $templates) . "</div>";
    }

    /**
     * Takes a directory and returns array with template realpaths.
     *
     * @param string $directory Full local path to directory.
     * @return array            Key-value array of templates realpaths.
     */
    protected function gatherTemplates($directory)
    {
        /** @var array */
        $templates = array();

        /** @var \RecursiveDirectoryIterator */
        $directory = new RecursiveDirectoryIterator($directory, RecursiveDirectoryIterator::SKIP_DOTS);
        /** @var \RecursiveIteratorIterator */
        $iterator = new RecursiveIteratorIterator($directory);
        /** @var \RegexIterator */
        $regex = new RegexIterator($iterator, '/^.+\.phtml$/i', RecursiveRegexIterator::ALL_MATCHES);

        /** Convert paths to array, where realpath are both keys and values. */
        foreach($regex as $path)
        {
            $path = realpath($path[0][0]);
            $templates[$path] = $path;
        }

        return $templates;
    }

    /**
     * Takes an array of templates, and renders it using the default engine.
     * The idea behind that was that Smarty and Angular are not playing nice together,
     * and a lot of additional code, mainly Smarty's {literal}{/literal},
     * would have to be written otherwise.
     *
     * @param array $templates Array of templates realpaths.
     * @return array           Array of templates realpaths as key, and template contents as values.
     */
    protected function render($templates)
    {
        /** @var \Zend\View\Renderer\PhpRenderer */
        $renderer = new PhpRenderer();
        /** @var \Zend\View\Resolver */
        $resolver = new Resolver\AggregateResolver();
        /** @var \Zend\View\Resolver\TemplateMapResolver */
        $map = new Resolver\TemplateMapResolver($templates);

        /** Attach templates generated by {@link ::gatherTemplates}. */
        $resolver->attach($map);
        /** Attach resolver to renderer. */
        $renderer->setResolver($resolver);

        /**
         * Pass current instance of {@link \Zend\View\HelperPluginManager} to new renderer,
         * so things like $this->translate() will be accessible.
         */
        $renderer->setHelperPluginManager($this->getView()->getHelperPluginManager());

        /** @var array Results of template rendering. */
        $renderedTemplates = array();

        /** Go over our templates and render them one by one, storing the results. */
        foreach($templates as $template)
        {
            $model    = new ViewModel();
            $model->setTemplate($template);
            $renderedTemplates[] = $renderer->render($model);
        }

        return $renderedTemplates;
    }
}